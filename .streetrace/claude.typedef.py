# type definitions file
# package: anthropic.types

from typing import Any, Iterable, Literal, Required, TypeAlias, TypedDict, Union
from pydantic import BaseModel
from typing import List, Optional

class RedactedThinkingBlock(BaseModel):
    data: str

    type: Literal["redacted_thinking"]

class ThinkingBlock(BaseModel):
    signature: str

    thinking: str

    type: Literal["thinking"]

class ToolUseBlock(BaseModel):
    id: str

    input: object

    name: str

    type: Literal["tool_use"]

class TextBlock(BaseModel):
    text: str

    type: Literal["text"]

class TextBlockParam(TypedDict, total=False):
    text: Required[str]

    type: Required[Literal["text"]]

ContentBlock: TypeAlias = Union[TextBlock, ToolUseBlock, ThinkingBlock, RedactedThinkingBlock]

Content: TypeAlias = Union[TextBlockParam]

class RedactedThinkingBlockParam(TypedDict, total=False):
    data: Required[str]

    type: Required[Literal["redacted_thinking"]]


class ThinkingBlockParam(TypedDict, total=False):
    signature: Required[str]

    thinking: Required[str]

    type: Required[Literal["thinking"]]

class ToolResultBlockParam(TypedDict, total=False):
    tool_use_id: Required[str]

    type: Required[Literal["tool_result"]]

    content: Union[str, Iterable[Content]]

    is_error: bool

class ToolUseBlockParam(TypedDict, total=False):
    id: Required[str]

    input: Required[object]

    name: Required[str]

    type: Required[Literal["tool_use"]]

class MessageParam(TypedDict, total=False):
    content: Required[
        Union[
            str,
            Iterable[
                Union[
                    TextBlockParam,
                    ToolUseBlockParam,
                    ToolResultBlockParam,
                    ThinkingBlockParam,
                    RedactedThinkingBlockParam,
                    ContentBlock,
                ]
            ],
        ]
    ]

    role: Required[Literal["user", "assistant"]]

class Message(BaseModel):
    id: str
    """Unique object identifier.

    The format and length of IDs may change over time.
    """

    content: List[ContentBlock]
    """Content generated by the model.

    This is an array of content blocks, each of which has a `type` that determines
    its shape.

    Example:

    ```json
    [{ "type": "text", "text": "Hi, I'm Claude." }]
    ```

    If the request input `messages` ended with an `assistant` turn, then the
    response `content` will continue directly from that last turn. You can use this
    to constrain the model's output.

    For example, if the input `messages` were:

    ```json
    [
      {
        "role": "user",
        "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"
      },
      { "role": "assistant", "content": "The best answer is (" }
    ]
    ```

    Then the response `content` might be:

    ```json
    [{ "type": "text", "text": "B)" }]
    ```
    """

    role: Literal["assistant"]
    """Conversational role of the generated message.

    This will always be `"assistant"`.
    """

    stop_reason: Optional[Literal["end_turn", "max_tokens", "stop_sequence", "tool_use"]] = None
    """The reason that we stopped.

    This may be one the following values:

    - `"end_turn"`: the model reached a natural stopping point
    - `"max_tokens"`: we exceeded the requested `max_tokens` or the model's maximum
    - `"stop_sequence"`: one of your provided custom `stop_sequences` was generated
    - `"tool_use"`: the model invoked one or more tools

    In non-streaming mode this value is always non-null. In streaming mode, it is
    null in the `message_start` event and non-null otherwise.
    """

    type: Literal["message"]
    """Object type.

    For Messages, this is always `"message"`.
    """
def create(
    messages: Iterable[MessageParam],
    **kwargs: Any,
) -> Message:
    pass